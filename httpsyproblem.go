// Package httpsyproblem provides a standard interface for handling
// API error responses in web applications.
// It implements RFC 7807 which specifies a way to carry machine-readable
// details of errors in a HTTP response to avoid the need
// to define new error response formats for HTTP APIs.
package httpsyproblem

import (
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"net/http"
	"path"
)

// Details implements the RFC 7807 model.
// Additional fields can be added by embedding Details inside another struct.
//
//  type MoreDetails struct {
//      httpsyproblem.Details
//      TraceID string `json:"trace_id" xml:"trace_id"`
//  }
//
//  httpsyproblem.Serve(w, r, MoreDetails{})
type Details struct {
	// A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail,omitempty" xml:"detail,omitempty"`

	// A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance,omitempty" xml:"instance,omitempty"`

	// The HTTP status code ([RFC7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty" xml:"status,omitempty"`

	// A short, human-readable summary of the problem
	// type. It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title,omitempty" xml:"title,omitempty"`

	// A URI reference [RFC3986] that identifies the
	// problem type. This specification encourages that, when
	// dereferenced, it provide human-readable documentation for the
	// problem type (e.g., using HTML [W3C.REC-html5-20141028]). When
	// this member is not present, its value is assumed to be
	// "about:blank".
	Type string `json:"type,omitempty" xml:"type,omitempty"`

	// XMLName is needed to marshal to XML.
	XMLName xml.Name `json:"-" xml:"urn:ietf:rfc:7807 problem"`

	wrappedError error
}

// New returns a Details with the Detail, Status and Title fields
// set according to code and err.
// If code is 0, the result of StatusCode(err) will be used instead.
func New(code int, err error) *Details {
	details := Details{Type: "about:blank"}

	if ptr, ok := err.(*Details); ok {
		details = *ptr
	} else if err != nil {
		details.Detail = err.Error()
	}

	if code == 0 {
		code = StatusCode(err)
	}

	details.Status = code
	details.Title = http.StatusText(code)
	details.wrappedError = err
	return &details
}

// Error implements the error interface and returns the Title field.
func (details *Details) Error() string { return details.Title }

// StatusCode implements the interface used by StatusCode.
func (details *Details) StatusCode() int { return details.Status }

// Unwrap implements the interface used by errors.Unwrap() and returns the wrapped error.
func (details *Details) Unwrap() error { return details.wrappedError }

func (details *Details) isDetails() bool { return true }

// Serve replies to a request by marshaling the error to JSON, XML
// or plain text depending on the request's Accept header.
// Serve also accepts errors that implement the http.Handler interface,
// in which case the error is in charge of marshaling itself.
func Serve(w http.ResponseWriter, r *http.Request, err error) {
	var h http.Handler
	var ok bool
	if h, ok = err.(http.Handler); !ok {
		if d, ok := err.(interface{ isDetails() bool }); !ok || !d.isDetails() {
			err = New(StatusCode(err), err)
		}
		h = errorProxy{err}
	}
	h.ServeHTTP(w, r)
}

func serveJSON(w http.ResponseWriter, r *http.Request, err error) {
	w.Header().Set("Content-Type", "application/problem+json; charset=utf-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.WriteHeader(StatusCode(err))
	if err := json.NewEncoder(w).Encode(err); err != nil {
		panic(err)
	}
}

func serveXML(w http.ResponseWriter, r *http.Request, err error) {
	w.Header().Set("Content-Type", "application/problem+xml; charset=utf-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.WriteHeader(StatusCode(err))
	encoder := xml.NewEncoder(w)
	if _, err := io.WriteString(w, xml.Header); err != nil {
		panic(err)
	}
	if err := encoder.Encode(err); err != nil {
		panic(err)
	}
}

type errorProxy struct{ error }

func (err errorProxy) Unwrap() error { return err.error }

func (err errorProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	for _, accept := range r.Header["Accept"] {
		if ok, _ := path.Match("*/*json*", accept); ok {
			serveJSON(w, r, err.error)
			return
		} else if ok, _ := path.Match("*/*xml*", accept); ok {
			serveXML(w, r, err.error)
			return
		}
	}
	http.Error(w, err.Error(), StatusCode(err))
}

// StatusCode reports the HTTP status code associated with err
// if it implements the StatusCode() int method,
// 504 Gateway Timeout if it implements Timeout() bool,
// 503 Service Unavailable if it implements Temporary() bool,
// 500 Internal Server Error otherwise, or 200 OK if err is nil.
// StatusCode will unwrap err to find the most precise status code.
func StatusCode(err error) int {
	if err == nil {
		return http.StatusOK
	}
	for ; err != nil; err = errors.Unwrap(err) {
		if sc, ok := err.(interface{ StatusCode() int }); ok {
			return sc.StatusCode()
		} else if to, ok := err.(interface{ Timeout() bool }); ok && to.Timeout() {
			return http.StatusGatewayTimeout
		} else if te, ok := err.(interface{ Temporary() bool }); ok && te.Temporary() {
			return http.StatusServiceUnavailable
		}
	}
	return http.StatusInternalServerError
}

// Wrap associates an error with a status code and wraps it in a Details.
func Wrap(code int, err error) error {
	return New(code, err)
}

// Wrapf is a shorthand for wrapping the result of fmt.Errorf.
func Wrapf(code int, format string, a ...interface{}) error {
	return New(code, fmt.Errorf(format, a...))
}
