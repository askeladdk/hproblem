// Package httpsyproblem provides a standard interface for handling
// API error responses in web applications.
// It implements RFC 7807 which specifies a way to carry machine-readable
// details of errors in a HTTP response to avoid the need
// to define new error response formats for HTTP APIs.
package httpsyproblem

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"path"
)

// Details implements the RFC 7807 model and can marshaled to JSON and XML.
//
// Additional fields can be added by embedding Details inside another struct:
//
//  type MoreDetails struct {
//      httpsyproblem.Details
//      TraceID string `json:"trace_id" xml:"trace_id"`
//  }
type Details struct {
	// A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail,omitempty" xml:"detail,omitempty"`

	// A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance,omitempty" xml:"instance,omitempty"`

	// The HTTP status code ([RFC7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty" xml:"status,omitempty"`

	// A short, human-readable summary of the problem
	// type. It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title,omitempty" xml:"title,omitempty"`

	// A URI reference [RFC3986] that identifies the
	// problem type. This specification encourages that, when
	// dereferenced, it provide human-readable documentation for the
	// problem type (e.g., using HTML [W3C.REC-html5-20141028]). When
	// this member is not present, its value is assumed to be
	// "about:blank".
	Type string `json:"type,omitempty" xml:"type,omitempty"`

	// XMLName is needed to marshal to XML.
	XMLName xml.Name `json:"-" xml:"urn:ietf:rfc:7807 problem"`

	wrappedError error
}

// New returns a Details with the Detail, Status and Title fields
// set according to code and err.
func New(code int, err error) Details {
	return *Wrap(code, err).(*Details)
}

// Error implements the error interface and returns the Title field.
func (details *Details) Error() string { return details.Title }

// StatusCode implements the interface used by StatusCode.
func (details *Details) StatusCode() int { return details.Status }

// Unwrap implements the interface used by errors.Unwrap() and returns the wrapped error.
func (details *Details) Unwrap() error { return details.wrappedError }

func (details *Details) serveJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/problem+json; charset=utf-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.WriteHeader(details.Status)
	if err := json.NewEncoder(w).Encode(details); err != nil {
		panic(err)
	}
}

func (details *Details) serveXML(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/problem+xml; charset=utf-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	w.WriteHeader(details.Status)
	encoder := xml.NewEncoder(w)
	if _, err := io.WriteString(w, xml.Header); err != nil {
		panic(err)
	} else if err := encoder.Encode(details); err != nil {
		panic(err)
	}
}

// ServeHTTP implements http.Handler and replies to the request with a problem details object
// in JSON or XML format depending on the Accept header header.
// Panics if an error occurred while marshaling.
func (details *Details) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	for _, accept := range r.Header["Accept"] {
		if ok, _ := path.Match("application/*json*", accept); ok {
			details.serveJSON(w, r)
			return
		} else if ok, _ := path.Match("application/*xml*", accept); ok {
			details.serveXML(w, r)
			return
		}
	}
	details.serveJSON(w, r)
}

// Error replies to the request by calling err's handler if it implements http.Handler
// or with a plain text message otherwise.
func Error(w http.ResponseWriter, r *http.Request, err error) {
	if h, ok := err.(http.Handler); ok {
		h.ServeHTTP(w, r)
		return
	}
	http.Error(w, err.Error(), StatusCode(err))
}

// StatusCode reports the HTTP status code associated with err
// if it implements the StatusCode() int method,
// 500 Internal Server Error otherwise, or 200 OK if err is nil.
func StatusCode(err error) int {
	if err == nil {
		return http.StatusOK
	} else if sc, ok := err.(interface{ StatusCode() int }); ok {
		return sc.StatusCode()
	} else if to, ok := err.(interface{ Timeout() bool }); ok && to.Timeout() {
		return http.StatusGatewayTimeout
	} else if te, ok := err.(interface{ Temporary() bool }); ok && te.Temporary() {
		return http.StatusServiceUnavailable
	}
	return http.StatusInternalServerError
}

// Wrap associates an error with a status code and wraps it in a Details.
// The Detail field is set to err.Error().
// The Status and Title fields are set according to code
// or to StatusCode(err) if code is 0.
func Wrap(code int, err error) error {
	details := Details{Type: "about:blank"}

	if ptr, ok := err.(*Details); ok {
		details = *ptr
	} else if err != nil {
		details.Detail = err.Error()
	}

	if code == 0 {
		code = StatusCode(err)
	}

	details.Status = code
	details.Title = http.StatusText(code)
	details.wrappedError = err
	return &details
}

// Wrapf is a shorthand for wrapping the result of fmt.Errorf.
func Wrapf(code int, format string, a ...interface{}) error {
	return Wrap(code, fmt.Errorf(format, a...))
}
